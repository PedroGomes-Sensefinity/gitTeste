image: docker:latest
variables:
   # When using dind service, you must instruct Docker to talk with
  # the daemon started inside of the service. The daemon is available
  # with a network connection instead of the default
  # /var/run/docker.sock socket.
  DOCKER_HOST: tcp://docker:2376
  # Specify to Docker where to create the certificates. Docker
  # creates them automatically on boot, and creates
  # `/certs/client` to share between the service and job
  # container, thanks to volume mount from config.toml
  DOCKER_TLS_CERTDIR: "/certs"
  # These are usually specified by the entrypoint, however the
  # Kubernetes executor doesn't run entrypoints
  # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4125
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  DOCKER_DRIVER: overlay2
  REPOSITORY_URL: sensehubaksecr.azurecr.io/ui-admin-v2
  K8S_NAMESPACE: hub
  REVISION: ui-admin-v2-$CI_COMMIT_REF_NAME-$CI_COMMIT_SHORT_SHA

services:
  - docker:19.03.5-dind

stages:
  - build
  - deploy

build:
  stage: build
  only:
    - master
  tags: 
    - sense-runner
  image:
    name: docker:latest
    entrypoint: [""]
  before_script:
    - until docker info; do sleep 1; done
  script:
    - echo "Build"
    - docker login sensehubaksecr.azurecr.io -u $ACR_USERNAME -p $ACR_PASSWORD
    - docker build -f Dockerfile . -t $REPOSITORY_URL:$REVISION
    - docker push $REPOSITORY_URL:$REVISION
  allow_failure: false

deploy:
  stage: deploy
  only:
    - master
  tags: 
    - sense-runner
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  script:
    - echo "Deploy on Azure using Agent"
    - kubectl config use-context $K8S_CONTEXT
    - kubectl config set-context --current --namespace=$K8S_NAMESPACE
    - sed -i "s/image_to_be_replaced/$REVISION/g" deployment.yaml
    # kubectl apply -f prod.yaml
    - kubectl apply -f deployment.yaml
    - sh check_pod_status.sh
  allow_failure: false
